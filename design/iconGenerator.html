<!--╔══════════════════════════════════════════════════════════════════════════════════════════╗
    ║                                Name: PixelIconCreator                                    ║
    ║                                Author: Carson Morris                                     ║
    ║                                   Date: 11/14/2024                                       ║
    ║                                      Rev: 1.3                                            ║
    ╚══════════════════════════════════════════════════════════════════════════════════════════╝-->

    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Pixel Icon Creator</title>
        <!-- Font Awesome for Icons -->
        <link
          rel="stylesheet"
          href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
          crossorigin="anonymous"
          referrerpolicy="no-referrer"
        />
        <!-- ICO.js Library for ICO Generation -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/icojs/3.0.0/ico.min.js" integrity="sha512-K4PfK+TJD7dlhXbJvDnku89azfU91hBiuzbXyjYTWQfL6V85LEF0lNoSBvr5JMHE1QbF0j+ABX2OzNrOjtTjJQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <!-- FileSaver.js for Saving Files -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <style>
            /* Reset and Base Styles */
            * {
                box-sizing: border-box;
                margin: 0;
                padding: 0;
            }
    
            body {
                font-family: 'Arial', sans-serif;
                background: linear-gradient(135deg, #1e3c72, #2a5298, #2980b9, #6dd5ed);
                color: #ecf0f1;
                display: flex;
                flex-direction: column;
                align-items: center;
                padding: 20px;
                min-height: 100vh;
                overflow: hidden;
                animation: fadeIn 1.5s ease-in-out;
            }
    
            @keyframes fadeIn {
                from { opacity: 0; }
                to { opacity: 1; }
            }
    
            /* Container to Wrap Header and Main Content */
            .container {
                width: 100%;
                max-width: 1400px; /* Increased from 1200px */
                margin: 0 auto;
                padding: 0 20px; /* Adds horizontal padding */
            }
    
            /* Header Styles */
            header {
                background: linear-gradient(145deg, #34495e, #2c3e50);
                color: #f1c40f;
                padding: 20px 40px; /* Increased horizontal padding */
                text-align: center;
                border-radius: 12px; /* Rounded edges */
                width: calc(100% + 40px); /* Allows overhang */
                margin: 0 -20px 20px; /* Negative margins to create overhang */
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
                position: relative;
            }
    
            .header-content {
                max-width: 1400px; /* Matches container's max-width */
                margin: 0 auto;
                padding: 0 40px; /* Adjusted padding */
                position: relative;
                display: flex;
                align-items: center;
                justify-content: center;
            }
    
            /* Home Link Styling */
            .home-link {
                position: absolute;
                left: 0px; /* Adjusted to match padding */
                top: 50%;
                transform: translateY(-50%);
                text-decoration: none;
                color: #f1c40f;
                font-size: 2rem;
            }
    
            /* Header Title */
            header h1 {
                font-size: 3.5rem; /* Increased font size */
                color: #f39c12;
                text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.2);
            }
    
            /* Credit Styling */
            .credit {
                position: absolute;
                bottom: 10px;
                right: 40px; /* Adjusted to match padding */
                font-size: 16px; /* Increased font size for better visibility */
                color: rgba(255, 255, 255, 0.9);
                font-style: italic;
            }
    
            /* Main Content Wrapper */
            #main-content {
                display: flex;
                gap: 30px; /* Increased gap */
                justify-content: center;
                flex-wrap: wrap; /* Allows wrapping on smaller screens */
            }
    
            /* Canvas Area */
            #canvas-container {
                position: relative;
                flex: 3;
                display: flex;
                justify-content: center;
                align-items: center;
                background-color: #34495e;
                padding: 30px; /* Increased padding */
                border-radius: 12px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                overflow: hidden;
                width: 100%;
                max-width: 1000px; /* Adjust as needed */
                max-height: 830px; /* Set a maximum height */
            }
    
            /* Grid Styling */
            #grid {
                display: grid;
                background-color: #ecf0f1;
                border: 2px solid #bdc3c7;
                image-rendering: pixelated;
                width: fit-content;
                height: fit-content;
                cursor: crosshair;
                user-select: none;
                transition: transform 0.3s ease;
            }
    
            .cell {
                width: 25px; /* Increased from 20px */
                height: 25px; /* Increased from 20px */
                border: 1px solid #bdc3c7;
                background-color: transparent;
                cursor: pointer;
                transition: background-color 0.2s, border-color 0.2s;
            }
    
            .cell:hover {
                border-color: #1abc9c; /* Turquoise on hover */
            }
    
            /* Control Panel */
            #controls {
                flex: 1;
                background: linear-gradient(145deg, #34495e, #2c3e50);
                color: #ecf0f1;
                padding: 30px; /* Increased padding */
                border-radius: 12px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                display: flex;
                flex-direction: column;
                gap: 25px; /* Increased gap */
                overflow-y: auto;
                width: 100%;
                max-width: 400px; /* Increased from 300px */
                max-height: 830px; /* Set a maximum height */
            }

            /* Scrollbar for WebKit Browsers (Chrome, Safari, Edge) */
            #controls::-webkit-scrollbar {
                width: 12px;
            }

            #controls::-webkit-scrollbar-track {
                background: #2c3e50; /* Matches the dark gradient in the theme */
                border-radius: 6px;
            }

            #controls::-webkit-scrollbar-thumb {
                background-color: #f1c40f; /* Matches the turquoise used in other elements */
                border-radius: 6px;
                border: 3px solid #2c3e50; /* Creates padding inside the track */
            }

            #controls::-webkit-scrollbar-thumb:hover {
                background-color: #f1c40f; /* Darker turquoise on hover */
            }

            #controls {
                overflow-x: hidden;
            }            
    
            /* Control Group */
            .control-group {
                display: flex;
                flex-direction: column;
                gap: 15px; /* Increased gap */
            }
    
            label {
                font-weight: bold;
                font-size: 18px; /* Increased font size */
            }
    
            /* Color History Picker */
            #color-history-container {
                display: flex;
                gap: 8px; /* Increased gap */
                padding: 8px; /* Increased padding */
                background-color: #2c3e50;
                border-radius: 5px;
                min-height: 40px; /* Increased min-height */
                align-items: center;
                overflow-x: auto;
                white-space: nowrap;
            }
    
            .color-history-swatch {
                width: 35px; /* Increased size */
                height: 35px; /* Increased size */
                border: 2px solid #ecf0f1;
                cursor: pointer;
                transition: transform 0.2s, border 0.2s;
            }
    
            .color-history-swatch:hover {
                transform: scale(1.1);
                border: 2px solid #f1c40f; /* Orange border on hover */
            }
    
            .color-history-swatch.selected {
                border: 2px solid #f1c40f; /* Orange border when selected */
            }
    
            /* Full Color Picker */
            #custom-color-picker {
                padding: 5px;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                width: 100%;
                height: 50px; /* Increased height */
                background-color: #34495e; /* Dark background */
                color: #ecf0f1;
                transition: background-color 0.3s ease;
                font-size: 16px; /* Increased font size */
            }
    
            #custom-color-picker:hover {
                background-color: #1abc9c; /* Turquoise on hover */
            }
    
            /* Brush Size Slider */
            #brush-size-selector {
                display: flex;
                align-items: center;
                gap: 15px; /* Increased gap */
            }
    
            #brush-size {
                -webkit-appearance: none;
                width: 100%;
                height: 10px; /* Increased height */
                background: #bdc3c7;
                outline: none;
                border-radius: 5px;
                opacity: 0.8; /* Increased opacity */
                transition: opacity .2s;
                cursor: pointer;
            }
    
            #brush-size:hover {
                opacity: 1;
            }
    
            #brush-size::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                width: 25px; /* Increased size */
                height: 25px; /* Increased size */
                border-radius: 50%;
                background: #f1c40f; /* Orange thumb */
                cursor: pointer;
                transition: background-color 0.3s ease;
            }
    
            #brush-size::-moz-range-thumb {
                width: 25px; /* Increased size */
                height: 25px; /* Increased size */
                border-radius: 50%;
                background: #f1c40f; /* Orange thumb */
                cursor: pointer;
                transition: background-color 0.3s ease;
            }
    
            /* Brush Size Display */
            #brush-size-display {
                font-size: 18px; /* Increased font size */
                min-width: 25px;
                text-align: center;
                color: #f1c40f; /* Orange text */
            }
    
            /* Opacity Slider */
            #opacity-selector {
                display: flex;
                align-items: center;
                gap: 15px; /* Increased gap */
            }
    
            #opacity {
                -webkit-appearance: none;
                width: 100%;
                height: 10px; /* Increased height */
                background: #bdc3c7;
                outline: none;
                border-radius: 5px;
                opacity: 0.8; /* Increased opacity */
                transition: opacity .2s;
                cursor: pointer;
            }
    
            #opacity:hover {
                opacity: 1;
            }
    
            #opacity::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                width: 25px; /* Increased size */
                height: 25px; /* Increased size */
                border-radius: 50%;
                background: #f39c12; /* Orange thumb */
                cursor: pointer;
                transition: background-color 0.3s ease;
            }
    
            #opacity::-moz-range-thumb {
                width: 25px; /* Increased size */
                height: 25px; /* Increased size */
                border-radius: 50%;
                background: #f39c12; /* Orange thumb */
                cursor: pointer;
                transition: background-color 0.3s ease;
            }
    
            /* Opacity Display */
            #opacity-display {
                font-size: 18px; /* Increased font size */
                min-width: 25px;
                text-align: center;
                color: #f39c12; /* Orange text */
            }
    
            /* Grid Size Selector */
            #grid-size-selector {
                display: flex;
                align-items: center;
                gap: 15px; /* Increased gap */
            }
    
            #grid-size {
                width: 100%;
                padding: 10px; /* Increased padding */
                font-size: 18px; /* Increased font size */
                border: none;
                border-radius: 5px;
                cursor: pointer;
                background-color: #34495e; /* Dark background */
                color: #ecf0f1; /* Light text */
                transition: background-color 0.3s ease;
            }
    
            #grid-size:hover {
                background-color: #1abc9c; /* Turquoise on hover */
            }
    
            /* Image Upload */
            #image-upload-group {
                display: flex;
                flex-direction: column;
                gap: 15px; /* Increased gap */
            }
    
            /* Styled Upload Button */
            #upload-button {
                padding: 15px; /* Increased padding */
                background-color: #1abc9c; /* Turquoise background */
                color: #ecf0f1;
                border: none;
                cursor: pointer;
                font-size: 18px; /* Increased font size */
                border-radius: 5px;
                transition: background-color 0.3s ease;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 15px; /* Increased gap */
            }
    
            #upload-button:hover {
                background-color: #16a085; /* Darker turquoise on hover */
            }
    
            /* Hide the actual file input */
            #image-upload {
                display: none;
            }
    
            /* Export Buttons Container */
            #export-buttons-container {
                display: flex;
                flex-direction: column;
                gap: 15px; /* Increased gap */
            }
    
            /* Subtitle for Download Image */
            #export-subtitle {
                font-weight: bold;
                font-size: 18px; /* Increased font size */
                margin-bottom: 15px; /* Increased margin */
                color: #f1c40f; /* Orange text */
            }
    
            /* Export Buttons */
            #export-buttons {
                display: flex;
                gap: 15px; /* Increased gap */
                flex-wrap: wrap;
            }
    
            /* Styled Export Buttons */
            .export-btn {
                flex: 1;
                padding: 15px; /* Increased padding */
                background-color: #f1c40f; /* Orange background */
                color: #34495e; /* Dark text */
                border: none;
                cursor: pointer;
                font-size: 18px; /* Increased font size */
                border-radius: 5px;
                transition: background-color 0.3s ease, transform 0.2s;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 15px; /* Increased gap */
                box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            }
    
            .export-btn:hover {
                background-color: #e67e22; /* Darker orange on hover */
                transform: translateY(-2px);
                box-shadow: 0 6px 12px rgba(0,0,0,0.3);
            }
    
            /* Tooltip Styling */
            .tooltip {
                position: relative;
                display: inline-block;
            }
    
            .tooltip .tooltiptext {
                visibility: hidden;
                width: 180px; /* Increased width */
                background-color: #34495e;
                color: #ecf0f1;
                text-align: center;
                border-radius: 6px;
                padding: 8px; /* Increased padding */
                position: absolute;
                z-index: 1;
                top: 125%; /* Position below the button */
                left: 50%;
                transform: translateX(-50%);
                opacity: 0;
                transition: opacity 0.3s;
                font-size: 16px; /* Increased font size */
            }        
    
            .tooltip:hover .tooltiptext {
                visibility: visible;
                opacity: 1;
            }
    
            /* Undo and Redo Buttons Inside the Sidebar */
            #history-buttons {
                display: flex;
                gap: 15px; /* Increased gap */
                margin-bottom: 25px; /* Increased margin */
            }
    
            .history-btn, .tool-btn {
                width: 50px; /* Increased size */
                height: 50px; /* Increased size */
                background-color: #1abc9c; /* Turquoise background */
                color: #ecf0f1;
                border: none;
                cursor: pointer;
                font-size: 20px; /* Increased font size */
                border-radius: 5px;
                transition: background-color 0.3s ease, transform 0.2s;
                display: flex;
                align-items: center;
                justify-content: center;
                box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            }
    
            .history-btn:hover, .tool-btn:hover {
                background-color: #16a085; /* Darker turquoise on hover */
                transform: scale(1.05);
                box-shadow: 0 6px 12px rgba(0,0,0,0.3);
            }
    
            .history-btn:disabled {
                background-color: #95a5a6;
                cursor: not-allowed;
                transform: none;
                box-shadow: none;
            }
    
            .tool-btn.selected {
                border: 2px solid #f1c40f; /* Orange border when selected */
            }
    
            /* Responsive adjustments */
            @media (max-width: 1024px) {
                /* Adjust max-widths for tablets and smaller devices */
                .container {
                    max-width: 1000px; /* Reduced max-width */
                    padding: 0 15px; /* Reduced padding */
                }
    
                header {
                    padding: 15px 30px; /* Reduced padding */
                    width: calc(100% + 30px);
                    margin: 0 -15px 15px;
                }
    
                .header-content {
                    padding: 0 30px; /* Reduced padding */
                }
    
                #canvas-container {
                    max-width: 800px; /* Reduced max-width */
                    padding: 20px;
                }
    
                #controls {
                    max-width: 350px; /* Reduced max-width */
                    padding: 20px;
                }
    
                .cell {
                    width: 20px; /* Reduced size */
                    height: 20px; /* Reduced size */
                }
    
                #history-buttons {
                    gap: 10px; /* Reduced gap */
                    margin-bottom: 20px;
                }
    
                .history-btn, .tool-btn {
                    width: 40px; /* Reduced size */
                    height: 40px; /* Reduced size */
                    font-size: 18px; /* Reduced font size */
                }
    
                /* Adjust export buttons */
                .export-btn {
                    padding: 12px;
                    font-size: 16px;
                    gap: 10px;
                }
    
                /* Adjust tooltips */
                .tooltip .tooltiptext {
                    width: 150px;
                    padding: 6px;
                    font-size: 14px;
                }
            }
    
            @media (max-width: 768px) {
                /* Adjustments for mobile devices */
                #main-content {
                    flex-direction: column;
                    align-items: center;
                }
    
                #controls {
                    max-width: 100%;
                }
    
                #grid-size-selector, #brush-size-selector, #opacity-selector {
                    flex-direction: column;
                    align-items: flex-start;
                }
    
                /* Stack export buttons vertically */
                #export-buttons {
                    flex-direction: column;
                }
    
                /* Adjust cell size for better touch support */
                .cell {
                    width: 30px; /* Increased size for touch */
                    height: 30px; /* Increased size for touch */
                }
    
                /* Adjust header title */
                header h1 {
                    font-size: 2.5rem; /* Reduced font size */
                }
    
                /* Adjust credit font size */
                .credit {
                    font-size: 12px; /* Reduced font size */
                }
            }
        </style>
    </head>
    <body>
    
        <!-- Container Wrapper -->
        <div class="container">
    
            <!-- Header -->
            <header>
                <div class="header-content">
                    <a href="../index.html" class="home-link">
                        <i class="fas fa-home"></i>
                    </a>
                    <h1>Pixel Icon Creator</h1>
                    <div class="credit">Created by: Carson Morris</div>
                </div>
            </header>
    
            <!-- Main Content Wrapper -->
            <div id="main-content">
    
                <!-- Canvas Area -->
                <div id="canvas-container">
                    <div id="grid">
                        <!-- Cells will be dynamically generated -->
                    </div>
                </div>
    
                <!-- Control Panel -->
                <div id="controls">
                    <!-- Undo and Redo Buttons -->
                    <div id="history-buttons">
                        <button class="history-btn tooltip" id="undo-btn" disabled>
                            <i class="fas fa-undo"></i>
                            <span class="tooltiptext">Undo (Ctrl+Z)</span>
                        </button>
                        <button class="history-btn tooltip" id="redo-btn" disabled>
                            <i class="fas fa-redo"></i>
                            <span class="tooltiptext">Redo (Ctrl+Y)</span>
                        </button>
                    </div>
    
                    <!-- Grid Size Selector -->
                    <div class="control-group" id="grid-size-group">
                        <label for="grid-size">Grid Size:</label>
                        <div id="grid-size-selector">
                            <select id="grid-size">
                                <option value="8">8x8</option>
                                <option value="16" selected>16x16</option>
                                <option value="24">24x24</option>
                                <option value="32">32x32</option>
                            </select>
                        </div>
                    </div>
    
                    <!-- Tools Group (Draw, Eraser, Paint Can, Move) -->
                    <div class="control-group">
                        <label>Tools:</label>
                        <div id="tools-group" style="display: flex; gap: 15px;">
                            <button class="tool-btn tooltip selected" id="draw-btn">
                                <i class="fas fa-pencil-alt"></i>
                                <span class="tooltiptext">Draw Tool</span>
                            </button>
                            <button class="tool-btn tooltip" id="eraser-btn">
                                <i class="fas fa-eraser"></i>
                                <span class="tooltiptext">Eraser Tool</span>
                            </button>
                            <button class="tool-btn tooltip" id="paint-can-btn">
                                <i class="fas fa-fill-drip"></i>
                                <span class="tooltiptext">Paint Can Tool</span>
                            </button>
                            <button class="tool-btn tooltip" id="move-btn">
                                <i class="fas fa-arrows-alt"></i>
                                <span class="tooltiptext">Move Tool</span>
                            </button>
                        </div>
                    </div>
    
                    <!-- Color Picker and History -->
                    <div class="control-group">
                        <label>Select Color:</label>
                        <!-- Custom Color Picker -->
                        <input type="color" id="custom-color-picker" class="tooltip" title="Choose a custom color">
                        <!-- History Label -->
                        <label for="color-history-container" style="margin-top:10px;">History:</label>
                        <div id="color-history-container">
                            <!-- Color History Swatches -->
                            <!-- These will be dynamically populated -->
                        </div>
                    </div>
    
                    <!-- Brush Size Slider -->
                    <div class="control-group">
                        <label for="brush-size">Brush Size:</label>
                        <div id="brush-size-selector">
                            <input type="range" id="brush-size" min="1" max="5" step="2" value="1">
                            <div id="brush-size-display">1</div>
                        </div>
                    </div>
    
                    <!-- Opacity Slider -->
                    <div class="control-group">
                        <label for="opacity">Opacity:</label>
                        <div id="opacity-selector">
                            <input type="range" id="opacity" min="0" max="100" step="1" value="100">
                            <div id="opacity-display">100%</div>
                        </div>
                    </div>
    
                    <!-- Export and Upload Buttons at the Bottom -->
                    <div class="control-group" id="upload-export-group">
                        <!-- Image Upload -->
                        <div id="image-upload-group">
                            <button id="upload-button" class="tooltip">
                                <i class="fas fa-upload"></i> Upload Image
                                <span class="tooltiptext">Upload and Pixelate Image</span>
                            </button>
                            <input type="file" id="image-upload" accept="image/*">
                        </div>
    
                        <!-- Export Buttons with Subtitle -->
                        <div class="control-group" id="export-buttons-container">
                            <div id="export-subtitle">Download Image:</div>
                            <div id="export-buttons">
                                <button class="export-btn tooltip" id="export-ico">
                                    <i class="fas fa-file-download"></i> Save as ICO
                                    <span class="tooltiptext">Download as ICO</span>
                                </button>
                                <button class="export-btn tooltip" id="export-png">
                                    <i class="fas fa-file-download"></i> Save as PNG
                                    <span class="tooltiptext">Download as PNG</span>
                                </button>
                                <button class="export-btn tooltip" id="export-bmp">
                                    <i class="fas fa-file-download"></i> Save as BMP
                                    <span class="tooltiptext">Download as BMP</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
    
            </div>
    
        </header>
    
        <!-- Hidden Canvas for Image Processing -->
        <canvas id="hidden-canvas" style="display: none;"></canvas>
    
        <script>
            window.addEventListener('DOMContentLoaded', function() {
                // ====================
                // DOM Element References
                // ====================
                const gridContainer = document.getElementById('grid');
                const colorHistoryContainer = document.getElementById('color-history-container');
                const customColorPicker = document.getElementById('custom-color-picker');
                const brushSizeSlider = document.getElementById('brush-size');
                const brushSizeDisplay = document.getElementById('brush-size-display');
                const opacitySlider = document.getElementById('opacity');
                const opacityDisplay = document.getElementById('opacity-display');
                const gridSizeSelector = document.getElementById('grid-size');
                const exportIcoBtn = document.getElementById('export-ico');
                const exportPngBtn = document.getElementById('export-png');
                const exportBmpBtn = document.getElementById('export-bmp');
                const imageUpload = document.getElementById('image-upload');
                const uploadButton = document.getElementById('upload-button');
                const hiddenCanvas = document.getElementById('hidden-canvas');
                const undoBtn = document.getElementById('undo-btn');
                const redoBtn = document.getElementById('redo-btn');
                const eraserBtn = document.getElementById('eraser-btn');
                const drawBtn = document.getElementById('draw-btn');
                const paintCanBtn = document.getElementById('paint-can-btn');
                const moveBtn = document.getElementById('move-btn');
    
                // ====================
                // Application State Variables
                // ====================
                let currentColor = '#000000'; // Default color
                let brushSize = 1; // Default brush size
                let gridSize = 16; // Default grid size (fixed to 16x16)
                let opacity = 1; // Default opacity (1 = fully visible)
                let isDrawing = false; // Drawing state
                let currentTool = 'draw'; // Current tool: 'draw', 'eraser', 'paintCan', 'move'
                let colorHistory = []; // Array to store last 6 used colors
    
                // ====================
                // Undo and Redo Stacks
                // ====================
                const undoStack = [];
                const redoStack = [];
                const MAX_HISTORY = 100; // Maximum number of states to store
    
                // ====================
                // Initialize the Grid
                // ====================
                function createGrid(newSize, existingColors = null) {
                    // Clear existing grid
                    gridContainer.innerHTML = '';
    
                    // Set grid template based on size
                    gridContainer.style.gridTemplateColumns = `repeat(${newSize}, 25px)`; // Updated cell size
                    gridContainer.style.gridTemplateRows = `repeat(${newSize}, 25px)`; // Updated cell size
                    gridContainer.style.transform = `translate(0px, 0px)`; // Reset any previous transforms
    
                    // Create grid cells
                    for (let i = 0; i < newSize * newSize; i++) {
                        const cell = document.createElement('div');
                        cell.classList.add('cell');
                        cell.dataset.index = i;
                        gridContainer.appendChild(cell);
                    }
    
                    // If existing colors are provided, map them to the new grid size
                    if (existingColors) {
                        for (let i = 0; i < newSize * newSize; i++) {
                            const cell = gridContainer.children[i];
                            cell.style.backgroundColor = existingColors[i] || 'transparent';
                        }
                    }
    
                    // Save initial state
                    saveState();
                    console.log('Grid created with size:', newSize);
                }
    
                // ====================
                // Map Colors from Old Grid to New Grid Size
                // ====================
                function mapColors(oldColors, oldSize, newSize) {
                    const newColors = [];
                    const scaleX = oldSize / newSize;
                    const scaleY = oldSize / newSize;
    
                    for (let y = 0; y < newSize; y++) {
                        for (let x = 0; x < newSize; x++) {
                            const oldX = Math.floor(x * scaleX);
                            const oldY = Math.floor(y * scaleY);
                            const oldIndex = oldY * oldSize + oldX;
                            newColors.push(oldColors[oldIndex] || 'transparent');
                        }
                    }
                    return newColors;
                }
    
                // ====================
                // Save Current State to Undo Stack
                // ====================
                function saveState() {
                    // Capture current state
                    const currentState = [];
                    for (let i = 0; i < gridSize * gridSize; i++) {
                        const cell = gridContainer.children[i];
                        const color = cell.style.backgroundColor || 'transparent';
                        currentState.push(color);
                    }
    
                    // Push to undo stack
                    undoStack.push(currentState);
    
                    // Limit undo stack size
                    if (undoStack.length > MAX_HISTORY) {
                        undoStack.shift();
                    }
    
                    // Clear redo stack
                    redoStack.length = 0;
    
                    // Update Undo/Redo button states
                    updateHistoryButtons();
                    console.log('State saved. Undo stack size:', undoStack.length);
                }
    
                // ====================
                // Restore State from a Given Array
                // ====================
                function restoreState(state) {
                    for (let i = 0; i < gridSize * gridSize; i++) {
                        const cell = gridContainer.children[i];
                        cell.style.backgroundColor = state[i];
                    }
                    console.log('State restored.');
                }
    
                // ====================
                // Undo Functionality
                // ====================
                function undo() {
                    if (undoStack.length > 1) {
                        const currentState = undoStack.pop();
                        redoStack.push(currentState);
                        const previousState = undoStack[undoStack.length - 1];
                        restoreState(previousState);
                        updateHistoryButtons();
                        console.log('Undo performed');
                    }
                }
    
                // ====================
                // Redo Functionality
                // ====================
                function redo() {
                    if (redoStack.length > 0) {
                        const nextState = redoStack.pop();
                        undoStack.push(nextState);
                        restoreState(nextState);
                        updateHistoryButtons();
                        console.log('Redo performed');
                    }
                }
    
                // ====================
                // Update Undo and Redo Button States
                // ====================
                function updateHistoryButtons() {
                    undoBtn.disabled = undoStack.length <= 1;
                    redoBtn.disabled = redoStack.length === 0;
                    console.log('Undo button:', undoBtn.disabled ? 'Disabled' : 'Enabled');
                    console.log('Redo button:', redoBtn.disabled ? 'Disabled' : 'Enabled');
                }
    
                // ====================
                // Handle Color Selection
                // ====================
                function selectColor(color) {
                    currentColor = applyOpacityToColor(color, opacity);
                    if (currentTool !== 'paintCan') {
                        currentTool = 'draw';
                        updateToolSelection();
                    }
                    // Update custom color picker value
                    customColorPicker.value = color;
                    console.log('Color selected:', currentColor);
                }
    
                // Helper function to apply opacity to a color
                function applyOpacityToColor(color, opacity) {
                    // Convert hex to RGB
                    const rgb = hexToRgb(color);
                    if (rgb) {
                        return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
                    }
                    return color;
                }
    
                // Helper function to convert hex to RGB
                function hexToRgb(hex) {
                    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
                    const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                    hex = hex.replace(shorthandRegex, function(m, r, g, b) {
                        return r + r + g + g + b + b;
                    });
    
                    const regex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                    return regex ? {
                        r: parseInt(regex[1], 16),
                        g: parseInt(regex[2], 16),
                        b: parseInt(regex[3], 16)
                    } : null;
                }
    
                // Helper function to convert rgb/rgba to hex
                function rgbToHexFromColor(color) {
                    const rgb = color.match(/\d+/g);
                    if (rgb && rgb.length >= 3) {
                        return rgbToHex(parseInt(rgb[0]), parseInt(rgb[1]), parseInt(rgb[2]));
                    }
                    return '#000000';
                }
    
                // ====================
                // Update Color History
                // ====================
                function updateColorHistory(color) {
                    // Only add to history if the color is not transparent and has been used on the canvas
                    if (color !== 'transparent') {
                        let hexColor;
                        if (color.startsWith('#')) {
                            hexColor = color;
                        } else {
                            // Convert rgba to hex
                            hexColor = rgbToHexFromColor(color);
                        }
                        if (!hexColor) return;
    
                        // Remove color if it already exists to prevent duplicates
                        colorHistory = colorHistory.filter(c => c.toLowerCase() !== hexColor.toLowerCase());
                        // Add the new color to the beginning
                        colorHistory.unshift(hexColor);
                        // Limit history to last 6 colors
                        if (colorHistory.length > 6) {
                            colorHistory.pop();
                        }
                        renderColorHistory();
                        console.log('Color history updated:', colorHistory);
                    }
                }
    
                // ====================
                // Render Color History
                // ====================
                function renderColorHistory() {
                    colorHistoryContainer.innerHTML = '';
                    colorHistory.forEach(color => {
                        const swatch = document.createElement('div');
                        swatch.classList.add('color-history-swatch');
                        swatch.style.backgroundColor = color;
                        swatch.dataset.color = color;
                        swatch.addEventListener('click', () => {
                            selectColor(color);
                            swatch.classList.add('selected');
                            // Remove 'selected' class from other swatches
                            document.querySelectorAll('.color-history-swatch').forEach(s => {
                                if (s !== swatch) {
                                    s.classList.remove('selected');
                                }
                            });
                        });
                        colorHistoryContainer.appendChild(swatch);
                    });
                    console.log('Color history rendered');
                }
    
                // ====================
                // Handle Custom Color Picker Change
                // ====================
                customColorPicker.addEventListener('input', (e) => {
                    const selectedColor = e.target.value;
                    selectColor(selectedColor);
                    // Do NOT add to color history here; only add when painted
                });
    
                // ====================
                // Handle Brush Size Selection
                // ====================
                function selectBrushSize(size) {
                    brushSize = parseInt(size);
                    brushSizeDisplay.textContent = size;
                    console.log('Brush size selected:', brushSize);
                }
    
                // ====================
                // Handle Opacity Selection
                // ====================
                function selectOpacity(value) {
                    opacity = parseInt(value) / 100;
                    opacityDisplay.textContent = `${value}%`;
                    // Update current color with new opacity
                    currentColor = applyOpacityToColor(rgbToHexFromColor(currentColor), opacity);
                    console.log('Opacity selected:', opacity);
                }
    
                // ====================
                // Handle Tool Selection
                // ====================
                function selectTool(tool) {
                    currentTool = tool;
                    updateToolSelection();
    
                    console.log('Tool selected:', currentTool);
                }
    
                // ====================
                // Update Tool Selection UI
                // ====================
                function updateToolSelection() {
                    // Remove 'selected' class from all tool buttons
                    document.querySelectorAll('.tool-btn').forEach(btn => {
                        btn.classList.remove('selected');
                    });
    
                    // Add 'selected' class to the current tool button
                    if (currentTool === 'draw') {
                        drawBtn.classList.add('selected');
                        gridContainer.style.cursor = 'crosshair';
                    } else if (currentTool === 'eraser') {
                        eraserBtn.classList.add('selected');
                        gridContainer.style.cursor = 'cell';
                    } else if (currentTool === 'paintCan') {
                        paintCanBtn.classList.add('selected');
                        gridContainer.style.cursor = 'url("https://cdn-icons-png.flaticon.com/512/2171/2171678.png"), auto'; /* Custom cursor for paint can */
                    } else if (currentTool === 'move') {
                        moveBtn.classList.add('selected');
                        gridContainer.style.cursor = 'grab';
                    }
                }
    
                // ====================
                // Paint Cell Function with Brush Size and Tool
                // ====================
                function paintCell(cell) {
                    const index = parseInt(cell.dataset.index);
                    const row = Math.floor(index / gridSize);
                    const col = index % gridSize;
    
                    const halfSize = Math.floor(brushSize / 2);
    
                    for (let r = row - halfSize; r <= row + halfSize; r++) {
                        for (let c = col - halfSize; c <= col + halfSize; c++) {
                            if (r >= 0 && r < gridSize && c >= 0 && c < gridSize) {
                                const cellIndex = r * gridSize + c;
                                const targetCell = gridContainer.children[cellIndex];
                                if (currentTool === 'eraser') {
                                    targetCell.style.backgroundColor = 'transparent';
                                } else if (currentTool === 'draw' || currentTool === 'paintCan') {
                                    targetCell.style.backgroundColor = currentColor;
                                    const hexColor = rgbToHexFromColor(currentColor);
                                    updateColorHistory(hexColor); // Add to history when painted
                                }
                            }
                        }
                    }
                    console.log(`Painted cell at index ${index} with color ${currentColor}`);
                }
    
                // ====================
                // Handle Mouse Down Event on Grid
                // ====================
                let isMoving = false;
                let initialDragPos = { x: 0, y: 0 };
                let accumulatedDelta = { x: 0, y: 0 };
                const cellSize = 25; // Updated to match cell size
    
                gridContainer.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('cell')) {
                        if (currentTool === 'move') {
                            isMoving = true;
                            gridContainer.classList.add('dragging');
                            initialDragPos = { 
                                x: e.clientX, 
                                y: e.clientY 
                            };
                            accumulatedDelta = { x: 0, y: 0 };
                            console.log('Move started');
                        } else {
                            isDrawing = true;
                            paintCell(e.target);
                            saveState();
                            console.log('Drawing started');
                        }
                    }
                });
    
                // ====================
                // Handle Mouse Move Event on Grid
                // ====================
                gridContainer.addEventListener('mousemove', (e) => {
                    if (isDrawing && currentTool !== 'move') {
                        if (e.target.classList.contains('cell')) {
                            paintCell(e.target);
                        }
                    }
    
                    if (isMoving && currentTool === 'move') {
                        const deltaX = e.clientX - initialDragPos.x;
                        const deltaY = e.clientY - initialDragPos.y;
    
                        // Accumulate the delta
                        accumulatedDelta.x += deltaX;
                        accumulatedDelta.y += deltaY;
    
                        // Update initial position
                        initialDragPos = { x: e.clientX, y: e.clientY };
    
                        // Check if accumulated delta exceeds cell size
                        while (Math.abs(accumulatedDelta.x) >= cellSize) {
                            if (accumulatedDelta.x > 0) {
                                shiftGrid('right');
                                accumulatedDelta.x -= cellSize;
                            } else {
                                shiftGrid('left');
                                accumulatedDelta.x += cellSize;
                            }
                        }
    
                        while (Math.abs(accumulatedDelta.y) >= cellSize) {
                            if (accumulatedDelta.y > 0) {
                                shiftGrid('down');
                                accumulatedDelta.y -= cellSize;
                            } else {
                                shiftGrid('up');
                                accumulatedDelta.y += cellSize;
                            }
                        }
                    }
                });
    
                // ====================
                // Handle Mouse Up Event to Stop Drawing/Moving
                // ====================
                document.addEventListener('mouseup', (e) => {
                    if (isDrawing) {
                        isDrawing = false;
                        saveState();
                        console.log('Drawing stopped');
                    }
    
                    if (isMoving) {
                        isMoving = false;
                        gridContainer.classList.remove('dragging');
                        saveState();
                        console.log('Move ended');
                    }
                });
    
                // ====================
                // Shift Grid Function
                // ====================
                function shiftGrid(direction) {
                    const newState = [];
                    for (let i = 0; i < gridSize * gridSize; i++) {
                        let targetIndex;
                        switch(direction) {
                            case 'up':
                                targetIndex = i + gridSize;
                                break;
                            case 'down':
                                targetIndex = i - gridSize;
                                break;
                            case 'left':
                                targetIndex = i + 1;
                                break;
                            case 'right':
                                targetIndex = i - 1;
                                break;
                            default:
                                targetIndex = i;
                        }
    
                        if (targetIndex >= 0 && targetIndex < gridSize * gridSize) {
                            newState[i] = gridContainer.children[targetIndex].style.backgroundColor || 'transparent';
                        } else {
                            newState[i] = 'transparent';
                        }
                    }
    
                    // Apply the new state
                    for (let i = 0; i < gridSize * gridSize; i++) {
                        gridContainer.children[i].style.backgroundColor = newState[i];
                    }
    
                    // Save the shift as a new state
                    saveState();
                    console.log(`Shifted ${direction}`);
                }
    
                // ====================
                // Handle Tool Button Clicks
                // ====================
                drawBtn.addEventListener('click', () => {
                    if (currentTool === 'draw') return;
                    selectTool('draw');
                });
    
                eraserBtn.addEventListener('click', () => {
                    if (currentTool === 'eraser') return;
                    selectTool('eraser');
                });
    
                paintCanBtn.addEventListener('click', () => {
                    if (currentTool === 'paintCan') return;
                    selectTool('paintCan');
                });
    
                moveBtn.addEventListener('click', () => {
                    if (currentTool === 'move') return;
                    selectTool('move');
                });
    
                // ====================
                // Handle Undo and Redo Button Clicks
                // ====================
                undoBtn.addEventListener('click', () => {
                    undo();
                });
    
                redoBtn.addEventListener('click', () => {
                    redo();
                });
    
                // ====================
                // Handle Upload Button Click
                // ====================
                uploadButton.addEventListener('click', () => {
                    imageUpload.click();
                });
    
                // ====================
                // Handle Image Upload and Pixelation
                // ====================
                imageUpload.addEventListener('change', (e) => {
                    if (e.target.files.length === 0) {
                        return;
                    }
    
                    const file = e.target.files[0];
                    const reader = new FileReader();
    
                    reader.onload = function(event) {
                        const img = new Image();
                        img.onload = function() {
                            // Set hidden canvas dimensions to grid size
                            hiddenCanvas.width = gridSize;
                            hiddenCanvas.height = gridSize;
                            const ctx = hiddenCanvas.getContext('2d');
    
                            // Draw the image scaled to grid size
                            ctx.clearRect(0, 0, gridSize, gridSize);
                            ctx.drawImage(img, 0, 0, gridSize, gridSize);
    
                            // Get pixel data
                            const imageData = ctx.getImageData(0, 0, gridSize, gridSize).data;
    
                            // Save state before making changes
                            saveState();
    
                            // Update grid cells based on image data
                            for (let i = 0; i < gridSize * gridSize; i++) {
                                const r = imageData[i * 4];
                                const g = imageData[i * 4 + 1];
                                const b = imageData[i * 4 + 2];
                                const a = imageData[i * 4 + 3];
                                const cellColor = a === 0 ? 'transparent' : rgbToHex(r, g, b);
                                const cell = gridContainer.children[i];
                                cell.style.backgroundColor = cellColor;
                                if (cellColor !== 'transparent') {
                                    updateColorHistory(cellColor);
                                }
                            }
    
                            // Save state after image load
                            saveState();
                            console.log('Image uploaded and pixelated');
                        }
                        img.onerror = function() {
                            alert('Failed to load the image. Please try a different file.');
                        }
                        img.src = event.target.result;
                    }
    
                    reader.onerror = function() {
                        alert('Failed to read the file. Please try again.');
                    }
    
                    reader.readAsDataURL(file);
                });
    
                // ====================
                // Utility function to convert RGB to Hex
                // ====================
                function rgbToHex(r, g, b) {
                    return "#" + [r, g, b].map(x => {
                        const hex = x.toString(16);
                        return hex.length === 1 ? '0' + hex : hex;
                    }).join('');
                }
    
                // ====================
                // Handle Export as ICO
                // ====================
                exportIcoBtn.addEventListener('click', async () => {
                    try {
                        // Create a canvas to draw the grid
                        const canvas = document.createElement('canvas');
                        canvas.width = gridSize;
                        canvas.height = gridSize;
                        const ctx = canvas.getContext('2d');
                
                        // Draw each cell onto the canvas
                        for (let i = 0; i < gridSize * gridSize; i++) {
                            const cell = gridContainer.children[i];
                            const color = cell.style.backgroundColor || 'rgba(0,0,0,0)';
                            ctx.fillStyle = color;
                            const x = i % gridSize;
                            const y = Math.floor(i / gridSize);
                            ctx.fillRect(x, y, 1, 1);
                        }
                
                        // Determine the scale to ensure the image does not exceed 256x256
                        const maxIconSize = 256;
                        const scale = Math.floor(maxIconSize / gridSize);
                        const scaledWidth = gridSize * scale;
                        const scaledHeight = gridSize * scale;
                
                        // Create a scaled canvas
                        const scaledCanvas = document.createElement('canvas');
                        scaledCanvas.width = scaledWidth;
                        scaledCanvas.height = scaledHeight;
                        const scaledCtx = scaledCanvas.getContext('2d');
                        scaledCtx.imageSmoothingEnabled = false;
                        scaledCtx.drawImage(canvas, 0, 0, scaledWidth, scaledHeight);
                
                        // Convert the scaled canvas to PNG data URL
                        const pngDataUrl = scaledCanvas.toDataURL('image/png');
                        const pngBlob = await (await fetch(pngDataUrl)).blob();
                        const pngArrayBuffer = await pngBlob.arrayBuffer();
                
                        // Construct ICO file structure
                        const icoBuffer = new ArrayBuffer(6 + 16 + pngArrayBuffer.byteLength);
                        const view = new DataView(icoBuffer);
                
                        // ICONDIR structure
                        view.setUint16(0, 0, true); // Reserved
                        view.setUint16(2, 1, true); // Type: 1 for ICO
                        view.setUint16(4, 1, true); // Count: number of images
                
                        // ICONDIRENTRY structure
                        view.setUint8(6, scaledWidth >= 256 ? 0 : scaledWidth); // Width (0 for 256)
                        view.setUint8(7, scaledHeight >= 256 ? 0 : scaledHeight); // Height (0 for 256)
                        view.setUint8(8, 0); // Number of colors (0 for no palette)
                        view.setUint8(9, 0); // Reserved
                        view.setUint16(10, 1, true); // Color planes (set to 1)
                        view.setUint16(12, 32, true); // Bits per pixel
                        view.setUint32(14, pngArrayBuffer.byteLength, true); // Image size
                        view.setUint32(18, 22, true); // Offset to image data (6 + 16)
                
                        // Copy PNG data into the buffer
                        const pngBytes = new Uint8Array(pngArrayBuffer);
                        const icoBytes = new Uint8Array(icoBuffer);
                        icoBytes.set(pngBytes, 22); // Start copying at byte offset 22
                
                        // Create a Blob from the ICO buffer
                        const icoBlob = new Blob([icoBytes], { type: 'image/x-icon' });
                
                        // Trigger the download using FileSaver.js
                        saveAs(icoBlob, 'icon.ico');
                        console.log('ICO exported successfully');
                    } catch (error) {
                        console.error('Export as ICO failed:', error);
                        alert('Failed to export as ICO. Check the console for details.');
                    }
                });
                    
                // ====================
                // Handle Export as PNG
                // ====================
                exportPngBtn.addEventListener('click', () => {
                    try {
                        const canvas = document.createElement('canvas');
                        canvas.width = gridSize;
                        canvas.height = gridSize;
                        const ctx = canvas.getContext('2d');
    
                        // Set transparent background
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
    
                        // Draw each cell onto the canvas
                        for (let i = 0; i < gridSize * gridSize; i++) {
                            const cell = gridContainer.children[i];
                            const color = cell.style.backgroundColor || 'rgba(0,0,0,0)';
                            ctx.fillStyle = color;
                            const x = i % gridSize;
                            const y = Math.floor(i / gridSize);
                            ctx.fillRect(x, y, 1, 1);
                        }
    
                        // Scale up the image for better visibility
                        const scale = 32; // Each pixel becomes 32x32 in the final image
                        const scaledCanvas = document.createElement('canvas');
                        scaledCanvas.width = gridSize * scale;
                        scaledCanvas.height = gridSize * scale;
                        const scaledCtx = scaledCanvas.getContext('2d');
                        scaledCtx.imageSmoothingEnabled = false;
                        scaledCtx.drawImage(canvas, 0, 0, scaledCanvas.width, scaledCanvas.height);
    
                        // Convert the scaled canvas to Blob and save as PNG
                        scaledCanvas.toBlob(function(blob) {
                            if (blob) {
                                saveAs(blob, 'icon.png');
                                console.log('PNG exported successfully');
                            } else {
                                console.error('Failed to generate PNG blob.');
                                alert('Failed to export as PNG.');
                            }
                        }, 'image/png');
                    } catch (error) {
                        console.error('Export as PNG failed:', error);
                        alert('Failed to export as PNG. Check the console for details.');
                    }
                });
    
                // ====================
                // Handle Export as BMP
                // ====================
                exportBmpBtn.addEventListener('click', () => {
                    try {
                        const canvas = document.createElement('canvas');
                        canvas.width = gridSize;
                        canvas.height = gridSize;
                        const ctx = canvas.getContext('2d');
    
                        // Set transparent background
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
    
                        // Draw each cell onto the canvas
                        for (let i = 0; i < gridSize * gridSize; i++) {
                            const cell = gridContainer.children[i];
                            const color = cell.style.backgroundColor || 'rgba(0,0,0,0)';
                            ctx.fillStyle = color;
                            const x = i % gridSize;
                            const y = Math.floor(i / gridSize);
                            ctx.fillRect(x, y, 1, 1);
                        }
    
                        // Scale up the image for better visibility
                        const scale = 32; // Each pixel becomes 32x32 in the final image
                        const scaledCanvas = document.createElement('canvas');
                        scaledCanvas.width = gridSize * scale;
                        scaledCanvas.height = gridSize * scale;
                        const scaledCtx = scaledCanvas.getContext('2d');
                        scaledCtx.imageSmoothingEnabled = false;
                        scaledCtx.drawImage(canvas, 0, 0, scaledCanvas.width, scaledCanvas.height);
    
                        // Convert canvas to BMP
                        const bmpBlob = canvasToBmp(scaledCanvas);
                        if (bmpBlob) {
                            saveAs(bmpBlob, 'icon.bmp');
                            console.log('BMP exported successfully');
                        } else {
                            console.error('Failed to generate BMP blob.');
                            alert('Failed to export as BMP.');
                        }
                    } catch (error) {
                        console.error('Export as BMP failed:', error);
                        alert('Failed to export as BMP. Check the console for details.');
                    }
                });
    
                // ====================
                // Function to Convert Canvas to BMP Format
                // ====================
                function canvasToBmp(canvas) {
                    try {
                        const ctx = canvas.getContext('2d');
                        const width = canvas.width;
                        const height = canvas.height;
                        const imageData = ctx.getImageData(0, 0, width, height).data;
    
                        // BMP file header
                        const fileSize = 54 + (width * height * 4);
                        const buffer = new ArrayBuffer(fileSize);
                        const view = new DataView(buffer);
    
                        // BITMAPFILEHEADER
                        view.setUint8(0, 0x42); // 'B'
                        view.setUint8(1, 0x4D); // 'M'
                        view.setUint32(2, fileSize, true); // File size
                        view.setUint16(6, 0, true); // Reserved1
                        view.setUint16(8, 0, true); // Reserved2
                        view.setUint32(10, 54, true); // Offset to pixel data
    
                        // BITMAPINFOHEADER
                        view.setUint32(14, 40, true); // Header size
                        view.setUint32(18, width, true); // Image width
                        view.setUint32(22, height, true); // Image height
                        view.setUint16(26, 1, true); // Planes
                        view.setUint16(28, 32, true); // Bits per pixel
                        view.setUint32(30, 0, true); // Compression
                        view.setUint32(34, width * height * 4, true); // Image size
                        view.setUint32(38, 0, true); // X pixels per meter
                        view.setUint32(42, 0, true); // Y pixels per meter
                        view.setUint32(46, 0, true); // Total colors
                        view.setUint32(50, 0, true); // Important colors
    
                        // Pixel data (BGRA format)
                        let offset = 54;
                        for (let y = height - 1; y >= 0; y--) { // BMP stores pixels bottom to top
                            for (let x = 0; x < width; x++) {
                                const i = (y * width + x) * 4;
                                const r = imageData[i];
                                const g = imageData[i + 1];
                                const b = imageData[i + 2];
                                const a = imageData[i + 3];
                                view.setUint8(offset++, b);
                                view.setUint8(offset++, g);
                                view.setUint8(offset++, r);
                                view.setUint8(offset++, a);
                            }
                        }
    
                        return new Blob([buffer], { type: 'image/bmp' });
                    } catch (error) {
                        console.error('Canvas to BMP conversion failed:', error);
                        return null;
                    }
                }
    
                // ====================
                // Handle Keyboard Shortcuts for Undo and Redo
                // ====================
                document.addEventListener('keydown', (e) => {
                    const key = e.key.toLowerCase();
                    if (e.ctrlKey && key === 'z') {
                        e.preventDefault();
                        undo();
                    }
                    if (e.ctrlKey && key === 'y') {
                        e.preventDefault();
                        redo();
                    }
                });
    
                // ====================
                // Initialize the Grid on Page Load
                // ====================
                createGrid(gridSize);
                colorHistory = [];
                renderColorHistory();
                brushSizeDisplay.textContent = brushSizeSlider.value;
                opacityDisplay.textContent = `${opacitySlider.value}%`;
                console.log('Grid initialized');
    
                // ====================
                // Prevent Text Selection While Moving
                // ====================
                document.body.addEventListener('mousedown', (e) => {
                    if (currentTool === 'move') {
                        e.preventDefault();
                    }
                });
    
                // ====================
                // Touch Support for Mobile Devices
                // ====================
                let touchStartPos = { x: 0, y: 0 };
                let accumulatedTouchDelta = { x: 0, y: 0 };
    
                gridContainer.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    const target = document.elementFromPoint(touch.clientX, touch.clientY);
                    if (target && target.classList.contains('cell')) {
                        if (currentTool === 'move') {
                            isMoving = true;
                            gridContainer.classList.add('dragging');
                            touchStartPos = { 
                                x: touch.clientX, 
                                y: touch.clientY 
                            };
                            accumulatedTouchDelta = { x: 0, y: 0 };
                            console.log('Touch move started');
                        } else if (currentTool === 'paintCan') {
                            // Handle touch for paint can
                            const index = parseInt(target.dataset.index);
                            const targetColor = gridContainer.children[index].style.backgroundColor || 'transparent';
                            const fillColor = currentColor;
    
                            if (colorsMatch(targetColor, fillColor)) return; // Prevent infinite loop
    
                            floodFill(index, targetColor, fillColor);
                            saveState();
                        } else {
                            isDrawing = true;
                            paintCell(target);
                            saveState();
                            console.log('Touch drawing started');
                        }
                    }
                });
    
                gridContainer.addEventListener('touchmove', (e) => {
                    const touch = e.touches[0];
                    const target = document.elementFromPoint(touch.clientX, touch.clientY);
                    const x = Math.floor((touch.clientX - gridContainer.getBoundingClientRect().left) / 25); // Updated cell size
                    const y = Math.floor((touch.clientY - gridContainer.getBoundingClientRect().top) / 25); // Updated cell size
    
                    if (isDrawing && currentTool !== 'move' && currentTool !== 'paintCan') {
                        if (target && target.classList.contains('cell')) {
                            paintCell(target);
                        }
                    }
    
                    if (isMoving && currentTool === 'move') {
                        const deltaX = touch.clientX - touchStartPos.x;
                        const deltaY = touch.clientY - touchStartPos.y;
    
                        // Accumulate the delta
                        accumulatedTouchDelta.x += deltaX;
                        accumulatedTouchDelta.y += deltaY;
    
                        // Update touch start position
                        touchStartPos = { x: touch.clientX, y: touch.clientY };
    
                        // Check if accumulated delta exceeds cell size
                        while (Math.abs(accumulatedTouchDelta.x) >= cellSize) {
                            if (accumulatedTouchDelta.x > 0) {
                                shiftGrid('right');
                                accumulatedTouchDelta.x -= cellSize;
                            } else {
                                shiftGrid('left');
                                accumulatedTouchDelta.x += cellSize;
                            }
                        }
    
                        while (Math.abs(accumulatedTouchDelta.y) >= cellSize) {
                            if (accumulatedTouchDelta.y > 0) {
                                shiftGrid('down');
                                accumulatedTouchDelta.y -= cellSize;
                            } else {
                                shiftGrid('up');
                                accumulatedTouchDelta.y += cellSize;
                            }
                        }
                    }
    
                    e.preventDefault();
                }, { passive: false });
    
                gridContainer.addEventListener('touchend', (e) => {
                    if (isDrawing) {
                        isDrawing = false;
                        saveState();
                        console.log('Touch drawing stopped');
                    }
    
                    if (isMoving) {
                        isMoving = false;
                        gridContainer.classList.remove('dragging');
                        saveState();
                        console.log('Touch move ended');
                    }
                });
    
                // ====================
                // Flood Fill Algorithm
                // ====================
                gridContainer.addEventListener('click', (e) => {
                    if (currentTool === 'paintCan') {
                        if (e.target.classList.contains('cell')) {
                            const index = parseInt(e.target.dataset.index);
                            const targetColor = gridContainer.children[index].style.backgroundColor || 'transparent';
                            const fillColor = currentColor;
    
                            if (colorsMatch(targetColor, fillColor)) return; // Prevent infinite loop
    
                            floodFill(index, targetColor, fillColor);
                            saveState();
                        }
                    } else if (currentTool === 'draw' || currentTool === 'eraser') {
                        if (e.target.classList.contains('cell')) {
                            paintCell(e.target);
                            saveState();
                        }
                    }
                });
    
                // Helper function to compare colors
                function colorsMatch(color1, color2) {
                    const rgba1 = parseRGBA(color1);
                    const rgba2 = parseRGBA(color2);
                    if (!rgba1 || !rgba2) return false;
                    return rgba1.r === rgba2.r && rgba1.g === rgba2.g && rgba1.b === rgba2.b && rgba1.a === rgba2.a;
                }
    
                // Helper function to parse RGBA color
                function parseRGBA(color) {
                    const regex = /rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/;
                    const match = regex.exec(color);
                    if (match) {
                        return {
                            r: parseInt(match[1]),
                            g: parseInt(match[2]),
                            b: parseInt(match[3]),
                            a: match[4] !== undefined ? parseFloat(match[4]) : 1
                        };
                    }
                    return null;
                }
    
                // Flood Fill Algorithm
                function floodFill(startIndex, targetColor, fillColor) {
                    const stack = [startIndex];
                    const visited = new Set();
    
                    while (stack.length > 0) {
                        const currentIndex = stack.pop();
    
                        if (visited.has(currentIndex)) continue;
                        visited.add(currentIndex);
    
                        const cell = gridContainer.children[currentIndex];
                        const cellColor = cell.style.backgroundColor || 'transparent';
    
                        if (!colorsMatch(cellColor, targetColor)) continue;
    
                        // Fill the cell
                        cell.style.backgroundColor = fillColor;
    
                        // Get neighboring indices
                        const neighbors = getNeighbors(currentIndex);
                        neighbors.forEach(neighbor => {
                            if (!visited.has(neighbor)) {
                                stack.push(neighbor);
                            }
                        });
                    }
                    console.log('Flood fill completed.');
                }
    
                // Helper function to get neighboring indices (4-directional)
                function getNeighbors(index) {
                    const neighbors = [];
                    const row = Math.floor(index / gridSize);
                    const col = index % gridSize;
    
                    // Up
                    if (row > 0) neighbors.push(index - gridSize);
                    // Down
                    if (row < gridSize - 1) neighbors.push(index + gridSize);
                    // Left
                    if (col > 0) neighbors.push(index - 1);
                    // Right
                    if (col < gridSize - 1) neighbors.push(index + 1);
    
                    return neighbors;
                }
    
                // ====================
                // Handle Brush Size Change
                // ====================
                brushSizeSlider.addEventListener('input', (e) => {
                    const size = e.target.value;
                    selectBrushSize(size);
                });
    
                // ====================
                // Handle Opacity Change
                // ====================
                opacitySlider.addEventListener('input', (e) => {
                    const value = e.target.value;
                    selectOpacity(value);
                    // Update current color with new opacity
                    if (currentTool === 'draw' || currentTool === 'paintCan') {
                        currentColor = applyOpacityToColor(rgbToHexFromColor(currentColor), opacity);
                    }
                });
    
                // ====================
                // Handle Grid Size Change
                // ====================
                gridSizeSelector.addEventListener('change', (e) => {
                    const newSize = parseInt(e.target.value);
                    const oldSize = gridSize;
                    const oldColors = [];
    
                    // Capture existing colors
                    for (let i = 0; i < oldSize * oldSize; i++) {
                        const cell = gridContainer.children[i];
                        oldColors.push(cell.style.backgroundColor || 'transparent');
                    }
    
                    // Update gridSize before mapping
                    gridSize = newSize;
                    const newColors = mapColors(oldColors, oldSize, newSize);
                    createGrid(newSize, newColors);
                    colorHistory = []; // Reset color history on grid size change
                    renderColorHistory();
                    console.log('Grid size changed to:', newSize);
                });
    
                // ====================
                // Handle Upload Button Click
                // ====================
                uploadButton.addEventListener('click', () => {
                    imageUpload.click();
                });
    
                // ====================
                // Handle Image Upload and Pixelation
                // ====================
                imageUpload.addEventListener('change', (e) => {
                    if (e.target.files.length === 0) {
                        return;
                    }
    
                    const file = e.target.files[0];
                    const reader = new FileReader();
    
                    reader.onload = function(event) {
                        const img = new Image();
                        img.onload = function() {
                            // Set hidden canvas dimensions to grid size
                            hiddenCanvas.width = gridSize;
                            hiddenCanvas.height = gridSize;
                            const ctx = hiddenCanvas.getContext('2d');
    
                            // Draw the image scaled to grid size
                            ctx.clearRect(0, 0, gridSize, gridSize);
                            ctx.drawImage(img, 0, 0, gridSize, gridSize);
    
                            // Get pixel data
                            const imageData = ctx.getImageData(0, 0, gridSize, gridSize).data;
    
                            // Save state before making changes
                            saveState();
    
                            // Update grid cells based on image data
                            for (let i = 0; i < gridSize * gridSize; i++) {
                                const r = imageData[i * 4];
                                const g = imageData[i * 4 + 1];
                                const b = imageData[i * 4 + 2];
                                const a = imageData[i * 4 + 3];
                                const cellColor = a === 0 ? 'transparent' : rgbToHex(r, g, b);
                                const cell = gridContainer.children[i];
                                cell.style.backgroundColor = cellColor;
                                if (cellColor !== 'transparent') {
                                    updateColorHistory(cellColor);
                                }
                            }
    
                            // Save state after image load
                            saveState();
                            console.log('Image uploaded and pixelated');
                        }
                        img.onerror = function() {
                            alert('Failed to load the image. Please try a different file.');
                        }
                        img.src = event.target.result;
                    }
    
                    reader.onerror = function() {
                        alert('Failed to read the file. Please try again.');
                    }
    
                    reader.readAsDataURL(file);
                });
    
                // ====================
                // Flood Fill Algorithm Helpers
                // ====================
    
                // The floodFill and getNeighbors functions are already defined above.
    
            });
        </script>
    </body>
    </html>
    